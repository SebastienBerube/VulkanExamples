RWTexture2D<float2> W_in : register(u0); // W (velocity field; working)
RWTexture2D<float> P_in : register(u1);  // P (pressure field)
RWTexture2D<float2> U_out : register(u2); // Velocity out

//Obstacles map (unused for now)
//Texture2D<float> O_in;
//SamplerState samplerO_in;

//TODO: Remove these push constants. They are not necessary, only present to temporarily
//      standardize push constants for all passes.
struct PushConstants
{
    float DeltaTime; //Unused. 
    float Time;      //Unused.
    int FrameNo;     //Unused.
};

[[vk::push_constant]]
PushConstants pc;

// Finishing for Project step (divergence free field calculation)
[numthreads(16, 16, 1)]
void main(uint2 tid : SV_DispatchThreadID)
{
    uint2 dim;
    W_in.GetDimensions(dim.x, dim.y);

    if(tid.x == 0 || tid.x == dim.x - 1 ||
       tid.y == 0 || tid.y == dim.y - 1)
    {
      U_out[tid] = float2(0.0,0.0);
      return;
    }

    float P1 = P_in[max(tid - int2(1, 0), 1)];
    float P2 = P_in[min(tid + int2(1, 0), dim - 2)];
    float P3 = P_in[max(tid - int2(0, 1), 1)];
    float P4 = P_in[min(tid + int2(0, 1), dim - 2)];

    float2 u = W_in[tid] - float2(P2 - P1, P4 - P3) * dim.y / 2;

    U_out[tid] = u;

    //Internal obstacles : Temporarily commented out
    /*
    float2 uv = (tid + 0.5) / dim;
    float du = 1. / dim.x, dv = 1. / dim.y; 

    float oCenter = O_in.SampleLevel(samplerO_in, uv, 0);
    float dx = O_in.SampleLevel(samplerO_in, uv + float2(du, 0), 0) - oCenter;
    float dy = O_in.SampleLevel(samplerO_in, uv + float2(0, dv), 0) - oCenter;
    float2 grad = float2(dx, dy);

    bool inside = oCenter > 0.5 ? 1.0 : 0.0;
    bool nullGrad = (abs(dx) + abs(dy) <= 0.0);

    if (inside)
    {   
        U_out[tid] = 0;
    }
    else if(!nullGrad)
    {
        float neighborObstacle = O_in.SampleLevel(samplerO_in, uv + normalize(grad) / dim.xy, 0);
        if (neighborObstacle >= 0.5)
        {
            U_out[tid] = -u;
        }
    }
    */

    float2 borderVal = float2(0.0,0.0); //-u
    //Boundary
    if (tid.x == 1) U_out[tid] = borderVal;
    else if (tid.y == 1) U_out[tid] = borderVal;
    else if (tid.x == dim.x - 2) U_out[tid] = borderVal;
    else if (tid.y == dim.y - 2) U_out[tid] = borderVal;
}